"story_id","epic","title","user_role","description","business_value","priority","story_points","dependencies","acceptance_criteria","technical_tasks","definition_of_done"
"US-000","Core Architecture & System Foundation","Establish Foundational Application Shell","Development Team","As a Developer, I need the basic solution structure with dependency injection and hosting configured for both the WPF client and Windows Service, so that there is a stable foundation to build and test new features upon.","Provides the essential, non-negotiable architectural backbone for the entire application. Completing this unblocks all future feature development by establishing the core project structure, service hosting, and dependency management patterns.","Must Have","8","[]","[{""scenario"":""WPF client starts with Dependency Injection"",""given"":""The solution has been built successfully"",""when"":""The WPF client application is launched"",""then"":""The application starts without errors, using a configured IServiceProvider to resolve and display the main window and its initial ViewModel.""},{""scenario"":""Windows Service installs and runs"",""given"":""The solution has been built successfully"",""when"":""The service executable is installed and started via `sc.exe`"",""then"":""The Windows Service transitions to a 'Running' state and logs a startup message, with its dependencies resolved from its IServiceProvider.""}]","[""Create the Visual Studio solution and all required projects (Client, Service, Infrastructure, etc.)"",""Configure Microsoft.Extensions.Hosting and DI for the WPF client in App.xaml.cs"",""Configure Microsoft.Extensions.Hosting and DI for the Windows Service in Program.cs""]","[""Solution structure is committed to source control."",""Both client and service projects build successfully."",""DI containers are correctly configured for both client and service."",""A basic ViewModel can be resolved and displayed in the WPF client."",""The background service can be installed, started, and stopped.""]"
"US-001","User Authentication & Authorization","Log In with Username and Password","Registered System User","As a Registered System User, I want to securely log in to the application using my unique username and password so that I can gain access to the system and use the features authorized for my role.","Enforces security and meets HIPAA compliance by ensuring only authorized personnel can access Protected Health Information (PHI). This is the primary gatekeeper for the entire application.","Must Have","5","[""US-000""]","[{""scenario"":""Successful login with valid credentials"",""given"":""I have an active user account"",""when"":""I enter my correct username and password and click 'Login'"",""then"":""I am granted access and the main application window is displayed.""},{""scenario"":""Login attempt with an incorrect password"",""given"":""I am on the login screen"",""when"":""I enter my correct username but an incorrect password"",""then"":""A generic error message 'Invalid username or password.' is displayed, and I remain on the login screen.""},{""scenario"":""Login attempt with a disabled account"",""given"":""My user account has been disabled by an administrator"",""when"":""I enter my correct username and password"",""then"":""An error message 'Your account has been disabled. Please contact an administrator.' is displayed.""}]","[""Design and implement User and Role database schema using EF Core."",""Implement BCrypt password hashing and verification service."",""Create the WPF LoginView and LoginViewModel."",""Implement the AuthenticationService to validate credentials against the database.""]","[""Passwords are confirmed to be stored in the database using BCrypt hashing."",""Login screen is displayed on application startup."",""Successful and failed login attempts behave as per acceptance criteria."",""Integration test for the AuthenticationService is passing.""]"
"US-002","User Authentication & Authorization","Access Features Based on Assigned Role","Authenticated User","As an Authenticated User, I want the application's features and UI controls to be enabled or disabled based on my assigned role (Technician or Administrator), so that I can only perform actions I am authorized for.","Enforces the principle of least privilege, a core HIPAA security requirement. It prevents unauthorized access to sensitive data and system configurations, reducing operational risk.","Must Have","5","[""US-001""]","[{""scenario"":""Technician has restricted access"",""given"":""I am logged in as a user with the 'Technician' role"",""when"":""I navigate through the application"",""then"":""The 'Administration' area and the 'Edit DICOM Metadata' button are hidden or disabled.""},{""scenario"":""Administrator has full access"",""given"":""I am logged in as a user with the 'Administrator' role"",""when"":""I navigate through the application"",""then"":""All features, including the 'Administration' area and 'Edit DICOM Metadata' button, are visible and enabled.""},{""scenario"":""Backend authorization prevents unauthorized actions"",""given"":""I am logged in as a 'Technician'"",""when"":""An attempt is made to programmatically invoke an admin-only action"",""then"":""The action is rejected by the system's business logic layer and an authorization error is generated.""}]","[""Create a centralized UserSessionService to hold the current user's role."",""Implement a reusable mechanism in WPF (e.g., IValueConverter) to control UI element visibility/state based on role."",""Add authorization checks to backend service methods for critical actions.""]","[""A centralized service manages the current user's session and role."",""E2E tests confirm that a Technician cannot see or access Admin functions."",""Unit tests confirm that service-layer methods throw authorization exceptions when called by an unauthorized role.""]"
"US-100","DICOM Network Services & Data Management","Receive and Store DICOM Studies (C-STORE SCP)","Administrator","As an Administrator, I want the system to function as a DICOM C-STORE SCP with a resilient, decoupled ingestion pipeline so that we can reliably receive studies from modalities and handle high-volume traffic without data loss.","Enables the primary data ingestion workflow for the entire system, ensuring high availability and reliability for clinical operations. The decoupled design prevents data loss and improves system throughput under load.","Must Have","13","[""US-000""]","[{""scenario"":""Successfully receive a DICOM study"",""given"":""The background service is running"",""when"":""An external DICOM modality sends a study via C-STORE"",""then"":""The service accepts the association, queues the study for processing, and returns a success status to the modality without waiting for the database write to complete.""},{""scenario"":""Study is persisted to the database and file system"",""given"":""A study's metadata has been published to the processing queue"",""when"":""The database writer consumer processes the message"",""then"":""The patient, study, series, and image metadata is correctly inserted into the database, the DICOM file is moved to its permanent hierarchical storage path, and the message is removed from the queue.""},{""scenario"":""Message processing survives broker restart"",""given"":""A study has been queued for processing"",""when"":""The RabbitMQ service is restarted"",""then"":""The message is not lost and is successfully processed after the service comes back online.""}]","[""Implement fo-dicom C-STORE SCP listener as an IHostedService."",""Implement RabbitMQ publisher in the SCP to queue received DICOM metadata."",""Implement RabbitMQ consumer to read from the queue and persist data using EF Core."",""Implement logic for moving DICOM files to the permanent hierarchical storage location.""]","[""The system can receive a DICOM study from a test SCU tool (e.g., DCMTK)."",""The received study's metadata appears correctly in the PostgreSQL database."",""The corresponding DICOM file is stored in the correct folder structure."",""Integration tests confirm message persistence and the end-to-end ingestion flow.""]"
"US-200","DICOM Viewer & Image Manipulation","View DICOM Images with Standard Tools","Technician","As a Technician, I want to open a DICOM study in a high-performance viewer and use standard tools like zoom, pan, and window/level, so that I can efficiently review and prepare images for analysis or printing.","Provides the primary clinical utility for image review, which is central to all user workflows. High performance is critical for diagnostic efficiency.","Must Have","13","[""US-100""]","[{""scenario"":""Render a monochrome DICOM image"",""given"":""A study is available in the local storage"",""when"":""I open the study"",""then"":""The first image is displayed correctly in the viewer, and the application remains responsive.""},{""scenario"":""Use interactive image manipulation tools"",""given"":""An image is displayed in the viewer"",""when"":""I use my mouse to zoom (scroll wheel), pan (drag), and adjust window/level (drag)"",""then"":""The image updates smoothly and in real-time in response to my actions.""},{""scenario"":""Apply window/level presets"",""given"":""A CT image is displayed in the viewer"",""when"":""I select a 'Lung' window preset from a dropdown"",""then"":""The image rendering immediately updates to the standard window/level values for lung tissue.""}]","[""Set up DirectX 11/12 context using Vortice.Windows hosted in a WPF control."",""Develop the pipeline to load DICOM pixel data into a GPU texture."",""Write HLSL pixel shaders to apply window/level and other transformations on the GPU."",""Implement user input handling to translate mouse actions into rendering transformations (zoom, pan).""]","[""A monochrome DICOM image can be loaded and displayed."",""Zoom, pan, and interactive window/level tools are functional and performant."",""The viewer component is integrated into the main application window."",""Performance meets requirements for responsiveness on target hardware.""]"
"US-300","Printing, PDF, and Email","Submit Print Job Asynchronously","Technician","As a Technician, I want to submit a print job and have the application immediately become responsive again, so that my workflow is not blocked while the document is being generated and sent to the printer.","Improves user efficiency and application usability by decoupling the UI from slow, blocking I/O operations, leading to a better user experience.","Must Have","8","[""US-000""]","[{""scenario"":""Submit a print job successfully"",""given"":""The background print service is running"",""when"":""I click the 'Print' button in the print preview UI"",""then"":""A print job message is published to a persistent RabbitMQ queue, and a non-blocking 'Print job queued' notification is displayed.""},{""scenario"":""Attempt to print when service is unavailable"",""given"":""The background print service is stopped"",""when"":""I open the print preview UI"",""then"":""The 'Print' button is disabled, and a notification informs me that the print service is unavailable.""},{""scenario"":""Print job is processed by the background service"",""given"":""A print job message is in the queue"",""when"":""The background service's consumer processes the message"",""then"":""The service generates the print document and spools it to the specified Windows printer.""}]","[""Implement a Named Pipe client in the WPF app to check service status."",""Implement a Named Pipe server in the Windows service to respond to status checks."",""Implement RabbitMQ message publishing for print jobs from the client."",""Implement a RabbitMQ consumer in the service to process print jobs using the Windows Print API.""]","[""Client correctly checks service status via Named Pipes."",""Client successfully publishes a persistent print job message to a durable queue."",""Service consumes the message and sends a job to the Windows Print Spooler."",""The entire workflow is covered by an E2E test.""]"
"US-400","Administration and Monitoring","Monitor System Health via Dashboard","Administrator","As an Administrator, I want to view a real-time system health dashboard, so that I can proactively monitor the status of the service, database, message queue, and storage.","Enables proactive system monitoring, reduces downtime, and accelerates troubleshooting by providing a centralized, real-time view of all critical component health.","Should Have","8","[""US-002""]","[{""scenario"":""View dashboard with all systems healthy"",""given"":""I am logged in as an Administrator and all system components are running correctly"",""when"":""I navigate to the 'System Health' dashboard"",""then"":""I see green status indicators for the Windows Service, PostgreSQL connectivity, and RabbitMQ connectivity.""},{""scenario"":""View message queue depths"",""given"":""There are 5 messages in the main processing queue and 1 message in the dead-letter queue"",""when"":""I view the health dashboard"",""then"":""The dashboard displays 'Main Queue: 5' and 'Dead-Letter Queue: 1'.""},{""scenario"":""View disk space warning"",""given"":""The available disk space on the DICOM storage volume drops below the configured warning threshold"",""when"":""I view the health dashboard"",""then"":""The disk space indicator is displayed in yellow or red to signify a warning state.""}]","[""Implement a background service (IHostedService) to periodically poll component statuses."",""Implement an IPC mechanism for the client to request health data from the service."",""Create the SystemHealthView and ViewModel in WPF to display the data."",""Implement logic to query RabbitMQ management API for queue depths and check disk space.""]","[""Dashboard UI is accessible only to Administrators."",""All health metrics are displayed and update periodically."",""The dashboard correctly reflects the status of stopped services or failed connections."",""Warning thresholds for metrics like disk space are configurable and functional.""]"